### 概述  
1.ECMAScript（ES）是 JavaScript 的语法标准  
2.前端JS的组成：ECMAScript（核心语言，不可替代）；BOM--浏览器（宿主对象，可替代）；DOM--文档对象模型（宿主对象，可替代）  
3.客户端JS在浏览器运行，服务端JS在node.js中运行.二者的核心语言都是ECMAScript  
4.JS在浏览器中的实现方式是通过JS引擎（chrome通过v8）  
5.JavaScript 只能够在浏览器中执行？不是，JavaScript 除了在浏览器中运行，还可以在其他的运行环境中运行，如 node.js 环境。目前 JavaScript 的运行环境有浏览器和 node.js 环境两种  
6.JavaScript 在浏览器中是如何运行的？浏览器下载 JavaScript 脚本文件后，由浏览器JavaScript 引擎解释执行。  
7.ECMAScript的版本：ES5（2009年12月发布）、ES6（2015年06月发布）、ES7（2016年06月发布）、ES8（2017年06月发布）、ES9（2018年06月发布）、ES10（2019年06月发布）  
8.JS语言特点：直译式脚本语言，解释型语言；弱类型、动态类型语言；  
### 数据类型以及存储转换  
#### 数据类型
1. ES5 数据类型（6种）及其划分（2类）：基本（原始）类型（Number、String、Boolean、Null、Undefined）；引用（对象）类型（Object（Array、Function、Date、String等））  
2. typeof：返回一个字符串，表示未经计算的操作数的类型。如a为number，b为string a+b后，a的类型仍为number。typeof operand  或者  typeof (operand)，其中括号可选。操作数如果是函数，返回object；如果是undefined，返回‘undefined’；  
instanceof用于对象。如果value是一个通过Constr构造器创建的对象，则返回true
3. 函数如果没有return，则返回值类型为undefined  
4. JavaScript 有七种内置类型：  
• 空值（null） • 未定义（undefined） • 布尔值（ boolean） • 数字（number） • 字符串（string） • 对象（object） • 符号（symbol，ES6 中新增） 除对象之外，其他统称为“基本类型”。   
5. typeof null === "object"; // true  
6. 数组也是对象。  
7. JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。  
8. 变量在未持有值的时候为 undefined。此时 typeof 返回 "undefined"；还没有在作用域中声明 过的变量，是 undeclared 的。undefined 是值的一种。undeclared 则表示变量还没有被声明过  

#### 基本数据类型转换  
1. 隐式类型转换：通常是某些操作的副作用，不易看出  
2. 显示类型转换：可以在代码中明显看出  
3. 规则：  
①转为Number：undefined-->NaN;null-->0; 强制转为number：parseInt()、parseFloat()、Number()  
NaN(Not a Number)NaN!=NaN；console.log( typeof  NaN);//number  
isNaN( ) 函数用来检测参数是否为 NaN 值，参数是 "NaN" 时返回 true，否则返回 false  
布尔型a转换为数值用a*/1;若a为undefined，转换为布尔，为！！a  
②转为string：直接加单引号；强制转换：String（）  
“+”运算符左右两侧有字符串时为拼接运算符  
运算符等级相同时，从左往右计算（var a=1; var b="2"; var c=3;则a+c+b=42）  
③转换为Boolean：undefined，null，NaN,"" 均是false；强制转换：Boolean（）  
逻辑运算符会将数据类型转换为布尔类型之后再做运算  
对象-->Number：对象会先转换为原始值，然后再转换为数字/String  
任何JS的值都可以转换为布尔值  
“-”把他的两个操作数转换为数字

#### 包装对象和数据类型转换  
（一） 包装对象  
1. 例：  
var flag = true;  
var sign = flag.toString();//等价于var sign=(new Boolean(flag)).toString(true);包装对象  
console.log(sign, typeof sign); //true,string  
存取字符串、数字或布尔值的属性时创建的临时对象称为包装对象，而undefined、null没有包装对象，也因此没有toString（）方法。包装对象用来处理属性的引用，一旦属性引用结束，包装对象就会销毁  
例：【引用str字符串的属性和方法，JavaScript就会将字符串值通过调用 new String(str)的方式转换为对象，这个对象继承了字符串的方法，并被用来处理属性的引用。一旦属性引用结束，这个创建的对象就会销毁。】  
var str="hello";  
str.charAt(0);//创建包装对象     
str.name="STRING";//创建包装对象，代码运行结束后，包装对象就被销毁  
console.log(str.name);//undefined,而且与上面一行不是同一个包装对象  
2. JavaScript对象是一种复合值:它是属性或已命名值的集合。通过“.” 符号来引用属性值。当属性值是-一个函数的时候，称其为方法。通过o. m()来调用对象o中的方法。  
3. 存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象。需要注意的是，可通过String(), Number()或Boolean()构造 函数来显式创建包装对象    
4. JavaScript中的“+”运算符可以进行数学加法和字符串连接操作。如果它的其中一个操作数是对象，则JavaScript将 使用特殊的方法将对象转换为原始值，而不是使用其他算术运算符的方法执行对象到数字的转换，“==” 相等运算符与此类似。如果将对象和一个原始值比较，则转换将会遵照对象到原始值的转换方式进行。  
（二） 数据类型转换  
1. 转换为 Object 类型：对象转换为自身；undefined 和 null 转换为空对象 {}；string/number/boolean 转换为包装对象。强制转换：Object()；  
2. Object 转换为 Number：先调用 valueOf() 方法，结果为原始值，返回；再调用 toString() 方法，结果为原始值，返回；原始值转换为 Number 类型  
如：[] --> 0; [2] --> 2; [2,3] --> NaN; {} --> NaN;  
var a={};//undefined  
Number(a);//NaN  
a.valueOf();//{}  
a.valueOf().toString();//"[object Object]"  
Number(a.valueOf().toString());//NaN  
3. Object转换为 String：先调用 toString() 方法，结果为原始值，返回；再调用 valueOf() 方法，结果为原始值，返回；原始值转换为 String 类型  
如：[] --> ""; [3] --> "3"; [1,2,3] --> "1,2,3"; {} --> "[object Object]"; function(){} --> "function(){}"  
4. Object 转换为 Boolean：任意对象转换为布尔值为 true，包括空对象  
5. 如果对象具有toString()方法，则调用这个方法。如果它返回一个原始值，JavaScript将这个值转换为字符串(如果本身不是字符串的话)，并返回这个字符串结果。如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么JavaScript会调用value0f()方法。如果存在这个方法，则JavaScript调用它。 如果返回值是原始值，JavaScript将这个值转换为字符串( 如果本身不是字符串的话)，并返回这个字符串结果。否则，JavaScript无法从toString()或value0f()获得- 一个 原始值，因此这时它将抛出一个类型错误异常。  
6. 在对象到数字的转换过程中，JavaScript做了同样的事情，只是它会首先尝试使用value0f()方法:  
如果对象具有value0f()方法，后者返回一个原始值，则JavaScript将这 个原始值转换为数字(如果需要的话)并返回这个数字。  
否则，如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回  
否则，JavaScript抛出一个类型错误异常。  
7. 
【注：在 JavaScript 中，真值（truthy）指的是在强制转换布尔值时，转换后的值为真的值。所有值都是真值，除非它们被定义为假值（falsy）（即除 false、0、""、null、undefined 和 NaN 以外皆为真值）】  
（三） 总结  
1. undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。  
2. String == Boolean，需要两个操作数同时转为Number。  
3. String/Boolean == Number，需要String/Boolean转为Number。  
4. Object == Primitive，需要Object转为Primitive（即将操作数转为原始类型的值，具体通过valueOf和toString方法）  
5. 要将任意值转换为数字或者字符串，首先会被转换为任意的原始值，然后再转换为最终的结果  
6. valueOf的默认实现会返回this,而toString ()的默认实现会返回类型信息  
7. ToPrimitive(input, PreferredType?)  
可选参数PreferredType表明转换后的类型:它可以是Number或String,具体取决于ToPr imitive的结果是希望转换成数字还是字符串。
如果PreferredType是Number，会执行以下步骤。  
(1)如果input是原始值，返回这个值(没有其他需要做的)。  
(2)否则，如果input是对象，调用input. value0f()。如果结果是原始值，返回结果。  
(3)否则，调用input. toString()。如果结果是原始值，返回结果。  
(4)否则，抛出一个TypeError (说明将输入转换为原始值出错了)。  
如果PreferredType是字符串，第二步和第三步会进行交换。PreferredType 也可以被省略，这种情况下，日期会被认为是String而其他值会被认为是Number。因此,+运算符和===运算符可以操作ToPrimitive()。  
（四） 注  
1. 分析 console.log([] == []) 输出的值  
两个值都是对象 (引用值) 时，比较的是两个引用值在内存中是否是同一个对象。 虽然左操作数和右操作数同为空数组， 但此 [] 非彼 []，在内存中是两个互不相关的空数组， 所以结果为 false。  
2. 分析 console.log([] == ![]) 输出的值  
①等号右边有 ! ，优先级比 == 更高，优先计算右边的结果。 [] 为非假值，所以右边的运算结果为 false，即：![] ==> false
② == 的两边分别是 object 和 boolean 类型的值，把 object 转换成 number 类型，需要对 object 进行 ToNumber 操作，即Number([].valueOf()) ==> 0；boolean 类型的值时先把这个值转换成 number 类型，右边转换成了 0，即Number(false) ==> 0。  

#### 变量与内存  
1. 一般来说，系统会划分出两种不同的内存空间：  
①栈内存（stack）：存储的值大小固定；由系统自动分配内存空间；空间小，运行效率高  
②堆内存（heap）：存储的值大小不定，可动态调整；由程序员通过代码进行分配；空间大，运行效率相对较低  
2.   
①基本类型的变量是存放在栈区的，特点：占用空间固定，空间小，运行效率高，比较、传参、复制的数据是数据值。基本类型的值不可变（如：var a="abc"; a.toUpperCase(); console.log(a);//仍为"abc")，其属性不能改变、添加或移除；基本类型的值直接访问（运行速率快）；基本类型复制---相互独立互不影响  
②引用类型的值是同时保存在栈内存和堆内存中的对象，特点：占用空间不固定，可动态调整；空间大，运行效率小；比较、传参、复制的数据是地址值。值可变。如 【var person = {name:'Lily'}; 其中堆区存放的是（具体值）该对象{name:'Lily'}，栈区存放的是变量person在堆区的地址 】；引用类型的值通过引用访问，不能直接访问（运行速率慢）  
3. 基本数据类型与引用类型的比较：值类型是判断变量的值是否相等（值比较）；引用类型是判断所指向的内存空间（地址）是否相同（引用比较）  
4. ECMAScript 中所有函数的参数都是按值来传递的  
5. 基本类型值：把变量里的数据值传递给参数，之后参数和变量互不影响。  
引用类型值：把对象的引用（地址）值传递给参数，参数和对象都指向同一个对象，相互影响。  
6. 变量声明-->内存中开辟空间（注：全局变量挂载在window对象上）；变量赋值：内存中存储值  

### 数组  
1. 在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、 数字、对象（object），甚至是其他数组，对数组声明后即可向其中加入值，不需要预先设定大小  
2. var a = [ ]; a.length; // 0   
3. 使用 delete 运算符可以将单元从数组中删除，但是请注意，单元删除后，数 组的 length 属性并不会发生变化。  
4. 如果字符串键值能够被强制类型转换为十进制数字的话，它 就会被当作数字索引来处理。var a = [ ]; a["13"] = 42; a.length; // 14  
### 字符串  
1. JavaScript 中的字符串和字符数组并不是一回事  
2. var a = "foo"; var b = ["f","o","o"]; 字符串和数组的确很相似，它们都是类数组：a.length=b.length=3  
3. JavaScript 中字符串是不可变的，而数组是可变的.字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符 串。而数组的成员函数都是在其原始值上进行操作。  
4. push--在末尾加元素；reverse()--字符串反转；split--转换为数组；join--将数组中的字符拼接回字符串  
5. 字符串可用+=拼接  
6. slice用于字符串截取  
7. 在JavaScript字符串中，反斜线\\有着特殊的用途，反斜线符号后加一个字符，就不再表示它们的字面含义了，比如，\n就是-一个转义字符它表示的是一个换行符。另一个例子是上节中提到的转义字符\'，表示单引号(或撇号)。  
\n  换行符  
\v  垂直制表符  
\f  换页符  
\r  回车符  
\"  双引号  
\'  撇号或单引号  
\\  反斜线  
\xXX 两位十六进制数  
\uXXXX  4位十六进制数  
8. JavaScript定义了RegExp()构造函数，用来创建表示文本匹配模式的对象。这些模式称为“正则表达式”(regular expression)，JavaScript采用Perl中的正则表达式语法。String和RegExp对象均定义了利用正则表达式进行模式匹配和查找与替换的函数。RegExp并不是JavaScript的基本类型。和Date一样，它只是一种具有实用API的特殊对象。正则表达式的语法很复杂，API也很丰富。在两条斜线之间的文本构成了一个正则表达式直接量。第二条斜线之后也可以跟随-一个或多个字母，用来修饰匹配模式的含义
### 布尔值  
布尔值包含toString()方法，因此可以使用这个方法将字符串转换为“true" 或“false”，但它并不包含其他有用的方法。除了这个不重要的API,还有三个重要的布尔运算符。  
“&&”运算符执行了逻辑与(AND)操作。当且仅当两个操作数都是真值时它才返回true;否则返回false。“II” 运算符是布尔或(OR) 操作，如果两个操作数其中之一为真值它就返回true,如果两个操作数都是假值则返回false.最后，一元操作符“!"执行了布尔非(NOT) 操作:如果操作数是真值则返回false;如果是假值，则返回true。  
### 全局对象  
全局对象(global object) 在JavaScript中有着 重要的用途:全局对象的属性是全局定义的符号，JavaScript程序可以直接使用。当JavaScript解释 器启动时(或者任何Web浏览器加载新页面的时候)，它将创建-一个新的全局对象，并给它一组定义的初始属性:  
●  全局属性，比如undefined、 Infinity和NaN  
●  全局函数，比如isNaN()、parseInt()和eval()   
●  构造函数，比如Date()、 RegExp()、 String()、 0bject()和Array()   
●  全局对象，比如Math和JSON  
全局对象的初始属性并不是保留字，但它们应该当做保留字来对待。  
在代码的最顶级一不 在任何函数内的JavaScript代码一可 以使用JavaScript关键字this来引用全局对象  
声明一个全局变量，可不用var   
例：var scope = "global";function f() {  
   console.1og(scope); // 输出"undefined",而不是"global"  
   var scope = "1ocal"; //变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的  
   conscle.1og(scope); // 输出"local"  
你可能会误以为函数中的第一行会输出 “global" ，因为代码还没有执行到var语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到v ar语句的时候，局部变量才会被真正赋值。因此，上述过程等价于: 将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置:  
function f() {  
var scope;//在函数顶部声明了局部变量  
console. log(scope);//变量存在，但其值是"undefined"  
scope = "local";//这里将其初始化并赋值  
console.1og(scope);，   //这里它具有了我们所期望的值  
}  
### 作用域链  
如果将一一个局部变量看做是自定义实现的对象的属性的话，那么可以换个角度来解读变量作用域。每-一段JavaScript代码(全局代码或函数)都有一个与之关联的作用域链(scope chain)。这个作用域链是一个对象列表或者链表，这组对象定义了这段代码“作用域中”的变量。当JavaScript需 要查找变量x的值的时候(这个过程称做“变量解析”(variable resolution) )，它会从链中的第一个对象开始查找，如果这个对象有一个名为x的属性，则会直接使用这个属性的值，如果第-一个对象中不存在名为x的属性,JavaScript会继续查找链上的下一个对象。如果第二个对象依然没有名为x的属性，则会继续查找下一个对象，以此类推。如果作用域链上没有任何一个对象含有属性x,那么就认为这段代码的作用域链.上不存在x，并最终抛出一个引用错误(ReferenceEror) 异常。  
在JavaScript的最顶层代码中(也就是不包含在任何函数定义内的代码)，作用域链由一个全局对象组成。在不包含嵌套的函数体内，作用域链上有两个对象，第一个是定义，函数参数和局部变量的对象，第二个是全局对象。在一个嵌套的函数体内，作用域链上至少有三个对象。理解对象链的创建规则是非常重要的。当定义一个函数时，它实际上保存一个作用域链。当调用这个函数时，它创建一个新的对象来存储它的局部变量，并将这个对象添加至保存的那个作用域链上，同时创建-一个新的更长的表示函数调用作用域的“链”。对于嵌套函数来讲，事情变得更加有趣，每次调用外部函数时，内部函数又会重新定义一遍。因为每次调用外部函数的时候，作用域链都是不同的。内部函数在每次定义的时候都有微妙的差别一在 每次调用外部函数时，内部函数的代码都是相同的，而且关联这段代码的作用域链也不相同。  
### 数字  
1. 数字前面的 0 可以省略：var a = 0.42; var b = .42;  
2. 特别大和特别小的数字默认用指数格式显示，与 toExponential() 函数的输出结果相同。 
var a = 5E10; a;// 50000000000    a.toExponential();  // "5e+10"   
3. tofixed(..) 方法可指定小数部分的显示位数；toPrecision(..) 方法用来指定有效数位的显示位数：  
4. 二进制浮点数中的 0.1 和 0.2 并不是十分精确，它们相加的结果并非刚好等于 0.3，而是一个比较接近的数字 0.30000000000000004，所以条件判断结果为 false。0.1 + 0.2 === 0.3; // false  
Infinity比任何一个数都大（NaN除外），-Infinity比任何一个数都小（NaN除外）  
5. JS不区分整数值和浮点数值，所有数字均用浮点数表示  
6. 任何数字直接量前添加负号（-）可以直接得到他们的负值  
7. 用一个数字序列表示一个十进制数。JS也能识别十六进制（即以0x或0X为前缀），禁止八进制直接量  
8. 浮点型可直接含有小数点，也可使用指数计数法（在实数后加字母e或E，后面再跟正负号，再加一个整型的指数）  
9. 算术运算符如：加法运算符（+）、减法运算符（-）、乘法运算符（*/）、除法运算符（/）、求余运算符（%）等。除此之外，可用Math对象的函数方法  
10. JavaScript中的算术运算在溢出(overflow) 、下溢(underflow) 或被零整除时不会报错。当数字运算结果超过了JavaScript所能表示的数字上限(溢出)，结果为一个特殊的无穷大(infinity) 值，在JavaScript中以Infinity表示。同样地，当负数的值超过了JavaScript所能表示的负数范围，结果为负无穷大，在JavaScript中以 - Infinity表示。无穷大值的行为特性和我们所期望的是- .致的:基于它们的加、减、乘和除运算结果还是无穷大值(当然还保留它们的正负号)。下溢(underflow) 是当运算结果无限接近于零并比JavaScript能表示的最小值还小的时候发生的-一种情形。这种情况下，JavaScript将 会返回0。当一个负数发生下溢时，JavaScript返回-个特殊的值“负零”。这个值(负零)几乎和正常的零完全一样，JavaScript程序员很少用到负零。被零整除在JavaScript并不报错:它只是简单的返回无穷大(Infinity) 或负无穷大.(-Infinity)。但有一个例外，零除以零是没有意义的，这种整除运算结果也是一一个非数字(not-a-number) 值，用NaN表示。无穷大除以无穷大、给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作数一起使用时都将返回NaN。  
11. -0 = +0  
12. avaScript中使用实数的时候，常常只是真实值的-一个近似表示  
13.  JavaSeript语言核心包括Date()构造函数，用来创建表示日期和时间的对象。日期对象不像数字那样是基本数据类型。
### 特殊数值  
1. undefined 类型只有一个值，即 undefined。null 类型也只有一个值，即 null。它们的名 称既是类型也是值。null 指空值，或曾赋过值，但是目前没有值；undefined 指没有值，从未赋值。undefined和null都没有属性  
null 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而 undefined 却是一个标识符，可以被当作变量来使用和赋值。永远不要重新定义 undefined.void 运算符返回 undefined 丢失的参数也是undefined  
2.NaN 意指“不是一个数字”（not a number），理解为“无效数值”“失败数值”或者“坏数值”可能更准确些。NaN 是一个特殊值，它和自身不相等，是唯一一个非自反的值。而 NaN != NaN 为 true.可以使用内建的全局工具函数 isNaN(..) 来判断一个值是否是 NaN  
  

### 值  
#### JS中的类型体系  
1. 在编程语言的语义和类型体系环境中，静态一般是指“编译时”或者“非运行时”,动态指的是“运行时”。  
2. JS是动态类型的语言，变量的类型在编译的时候是不确定的。  
3. 静态类型检查语言会在编译期间进行检查，动态类型检查语言会在执行期间进行检查。  
4. JavaScript内置的转换机制只支持布尔值、数字、字符串和对象。没有标准的方法将某个构造函数的实例转换为另一个构造函数的实例。  
#### 原始值和对象  
1. 每一个对象有唯一的标识符并且只和自身相等  
例：var obj3=obj1;   obj3===obj1;//true  
相反，所有的原始值，只要编码相同，则被认为相等  
2. var a='abc'; a.length=1; console.log(a.length);//仍为3  
3. 对象的特点：①按引用进行比较，如：{}==={} --> false。②默认可变。③用户可扩展  
#### undefined和null  
1. undefined表示“ 没有值”(既不是原始值也不是对象)。访问未初始化的变量、缺失的参数，以及缺失的属性会返回这个空值。并且如果函数中没有任何显式的返回值时，则会隐式地返回undefined.  
2. null的意思是“没有对象”。在用到对象的时候它表示空值( 比如参数、对象链中的最后一个元素等)。  
3. 检测null或undefined：①用if(x===null); if(x===undefined);②大多数函数允许使用undefined或null来表示缺省值。③另一种检测方式是利用undefined和null都可被认为是false的特性  
#### 原始值的包装对象  
1. 通过调用包装构造函数来对原始值进行包装：new Number(123)；通过调用valueOf()来对原始值进行去包装：new Boolean(123).valueOf()  
2. 将包装对象转换为原始值是只能正确的提取出数字和字符串，而布尔值不能  
3. 存取字符串、数字或布尔值的属性时创建的临时对象称为包装对象  

### 语法  
1. 等于号的两种不同用法：①一个单独的等于号，用于为变量赋值；②三个连续的等号，用于比较两个值  
2. JS中的两种注释：单行注释：由//开始；多行注释：/* */  
3. 每个对象都有唯一的标识且只等于自己（所有的非基本数据类型外，都是对象）  
4. 原始布尔类型包含true和false。二元逻辑运算符（&&与、||或）、前置逻辑运算符（！非）、比较运算符【相等运算符===、！==、==、！= ；排序运算符（针对字符串及数字）>,<,>=,<=】这些运算符会产生布尔值  
### 标识符  
1. 标识符是代码中用来标识变量、函数、或属性的字符序列，命名规则：由字母、数字、下划线和$符号组成；不能以数字开头；大小写敏感（区分大小写）（注意：标识符不能和 JavaScript 其它关键字同名）  
2. 保留字在某种意思上是为将来的关键字而保留的单词。因此保留字不能被用作变量名或函数名。
3. 访问对象属性方式： 通过点号(.)运算符：点号要求后面的属性名是合法的标识符，对于不合法的不可以使用。通过中括号([])运算符：中括号要求的则是一个字符串即可，不必是合法的标识符  
若对象foo有属性att，则可：foo.att;  foo["att"];  foo["a"+"t"+"t"];  var key="att";foo[key];  
对象属性名如果是纯数字，可省略引号，除此以外，不合法的属性名必须加引号  
不管使用哪种形式的属性访问表达式，在“.”和“【”之前的表达式总是会首先计算。如果计算结果是null或者undefined,表达式会抛出一个类型错误异常，因为这两个值都不能包含任意属性。如果运算结果不是对象(或者数组)，JavaScript会将其转换为对象。如果对象表达式后跟随句点和标识符，则会查找由这个标识符所指定的属性的值，并将其作为整个表达式的值返回。如果对象表达式后跟随一对方括号，则会计算方括号内的表达式的值并将它转换为字符串。不论哪种情况，如果命名的属性不存在，那么整个属性访问表达式的值就是undefined.


4. Window对象的属性：全局变量是 window 对象的属性。全局函数是 window 对象的方法   
### 表达式    
1. 运算符的优先级决定了表达式中运算执行的先后顺序，优先级高的运算符最先被执行。  
2. 字面量，就是表示自身的常量。如12，“hello world”，{x：1，y:2}，[1,2,3]  
3. 表达式将产生一个值，用于需要值的地方  
4. JavaScript 解析器识别函数声明的条件是以 function 关键字开始，只要在 function 关键字的前面有任何其他的元素，就会从函数声明转变为函数表达式。在function前面加！、+、 - 甚至是逗号等到都可以起到识别为函数表达式的效果。在这些运算符中加括号是最安全的做法，因为它不会改变函数的返回值。因此形成立即执行表达式    
如：（function(a,b){  
       return a+b  
     }）(1,2);  
5. 最简单的表达式是“原始表达式”，原始表达式是表达式的最小单位，他们不再包含其他表达式。js中的原始表达式包含常量或直接量、关键字和变量。  
直接量是直接在程序中出现的常数值。  
JS中的一些保留字构成了原始表达式，如true，false，null，this  
变量如：sum，undefined  
#### 对象和数组的初始化表达式  
数组初始化表达式是通过一对方括号和其内由逗号隔开的列表构成的。初始化的结果是一个新创建的数组。数组的元素是逗号分割的表达式的值  
#### 调用表达式  
JavaScript中的调用表达式是一种调用(或者执行)函数或方法的语法表示。它以一个函数表达式开始，这个函数表达式指代了要调用的函数。函数表达式后跟随- -对圆括号，括号内是一个以逗号隔开的参数列表，参数可以有0个也可有多个，例如:   
f(0)  // f是-一个函数表达式; 0是一个参数表达式  
Math.max(x,y,z)  11 Math.max 是一个函数; x, y和z是参数  
a. sort()  // a.sort是一个函数，它没有参数  
当对调用表达式进行求值的时候，首先计算函数表达式，然后计算参数表达式，得到一一组参数值。如果函数表达式的值不是一个可调用的对象，则抛出-一个类型错误异常(所有的函数都是可调用的，即使宿主对象不是函数它也有可能被调用)。然后，实参的值被依次赋值给形参，这些形参是定义函数时指定的，接下来开始执行函数体。如果函数使用return语句给出一个返回值，那么这个返回值就是整个调用表达式的值。否则，调用表达式的值就是undefined。函数调用一包括 当形参表达式的个数和函数定义中实参的个数不匹配的时候的运行情况   
任何一个调用表达式都包含一对圆括号和左圆括号之前的表达式。如果这个表达式是一个属性访问表达式，那么这个调用称做“方法调用”。在方法调用中，执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内this的指向。  
#### 对象创建表达式  
对象创建表达式和函数调用表达式非常类似，只是对象创建表达式之前多了一个关键字new:  
new 0bject()new Point(2,3)  
如果一个对象创建表达式不需要传人任何参数给构造函数的话，那么这对空圆括号是可以省略掉的:  
new objectnew Date  
当计算一个对象创建表达式的值时，和对象初始化表达式通过{}创建对象的做法一样，JavaScript首先创建一个新的空对象，然后，JavaScript通过传人指定的参数并将这个新对象当做this的值来调用一个指定的函数。这个函数可以使用this来初始化这个新创建对象的属性。那些被当成构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果一个构造函数确实返回了一个对象值，那么这个对象就作为整个对象创建表达式的值，而新创建的对象就废弃了  
#### 表达式计算  
eval（）

### 运算符  
在JS中，变量、对象属性和数组元素均是左值
#### 逻辑运算符  
1. 逻辑运算符两边的操作数都是布尔类型  
 对于&&来说， 除了两侧都为真时为真，其他情况都为假  
 对于 | | 来说， 除了两侧都为假时为假，其他情况都为真  
2. 当逻辑运算符 && 和 || 两侧的操作数不是布尔类型时  
 首先将左操作数转换成布尔类型  
 对转换后的左操作数进行逻辑判断（true or false）  
 根据短路原则返回原始左操作数或原始右操作数  
3. 短路原则（忽略对右操作数的判断）  
 对于 &&，转换后的左操作数若为 true，则直接返回原始右操作数，若为 false 则直接返回原始左操作数  
 对于 | |，转换后的左操作数若为 true，则直接返回原始左操作数，若为 false 则直接返回原始右操作数  
4. ①遵循短路特性，使用 || 来设置函数参数的默认值  
 函数定义时可以给参数指定默认值，调用时若未传参数则该参数的值取它定义时的默认值  
   ②遵循短路特性，使用 && 防止运行报错  
   ③遵循短路特性，使用 && 和 || 可用来实现条件语句  
5. !(p&&q) === !p||!q  
   !(p||q) === !p&&!q  
#### 相等运算符  
1.  JavaScript 有两种比较方式：严格比较运算符和宽松比较运算符。  
 严格相等运算符（===）：仅当两个操作数的类型相同且值相等为 true  
 宽松相等运算符（==）：在进行比较之前，将两个操作数转换成相同的类型  
●严格相等(===) 和严格不等(!==)要求比较的值必须是相同的类型。  
●普通(或者“宽松”)相等(==) 和不等(!=) 会先尝试将两个不同类型的值进行转换，再使用严格相等进行比较。  
宽松相等可能会存在两个问题。第一，执行转换的过程令人困惑:第二，由于运算符的宽容特性，使得类型错误可能长时间不能被发现。  
①严格相等中：x !== y ==> !(x === y)  
②普通相等的比较算法原理如下。如果两个运算数的类型相同(六种规范类型: Undefined,Null,Boolean,Number,String和Object其中之一)，则使用严格相等比较它们。  
      否则，如果运算数是如下类型。  
      1. undefined 和null，则它们被认为是宽松相等的。undefined = null  
      2. 一个字符串和一个数字，则将字符串转换为一个数字，使用严格相等比较两个运算数。  
      3.一个布尔值和一个非布尔值，则将布尔值转换为一个数字，然后(再次)进行宽松比较。  
      4.一个对象和一个数字或者一个字符串，则尝试转换此对象为一个原始值，然后(再次)进行宽松比较。  
      其他情况一不符合上述提到的情况，宽松比较的结果是false.  
      x != y ==> !(x == y)
2.  
2==true//2===1,false   2==false//2===0,false   1==true//1===1,true   0==false//0===0,true  
''==false//0===0,true  '1'==true//1===1,true  '2'==true//2===1,false  'abc'==true//NaN===1,false  
'abc'==new String('abc')//'abc'=='abc',true  '123'='123'//123===123,true  '\n\t123\r'==123//true  ''==0//true  
{}=='[object Object]'//true  ['123']==123//true  []==0//true  new Boolean(true/123/'abc')===new Boolean(true/123/'abc')//false  
  

#### 赋值运算符  
1. 左值：“=”运算符的左操作数。右值：“=”运算符的右操作数  
2. 赋值表达式的返回值为右操作数  
function fun(){  
        var a = b = 5;  
    }  
    fun();  
    console.log(a,typeof a);//判断变量a是不是未定义 true  
    console.log(b,typeof b);//判断变量b是不是未定义 false b的值是5  
    //var只对a有效，a是局部变量，b是全局变量。是因为赋值从右向左结合，var a=b=5; 等价于 var a=(b=5);其中只有a被声明了，b是自动解析为全局变量了。  
3. 普通的赋值运算有多种使用方式:  
①x = value  
给前面已声明的变量x赋值。  
②var X = value  
在声明变量的时候直接赋值。  
③obj .propKey = value  
设置属性。  
④objl'propKey'] = value  
设置属性。  
⑤arr[index] = value  
设置数组元素。  
4. 复合赋值运算符被写成op=的形式，其中op是一种二元运算符，=是赋值运算符。以下两个表达式是等价的:  
myvar op= value  
myvar = myvar op value  
换句话说，复合赋值运算符op=对两边的运算数做op运算，并将结果赋值给第一个运算数  
5. 优先级很低  
#### 逗号运算符  
1. 对它的每个操作数求值（从左到右），并返回最后一个操作数的值  
逗号运算符会执行两边的运算数并返回right部分的结果。  

#### 排序运算符  
1. <、<=、>、>=  
(1)确保两个运算数是原始值。obj 对象通过内部的ToPrimitive(obj, Number)方法转换成原始值，这会调用obj.valueOf()方法或者obj.toString()来实现。  
(2)如果两个运算数都是字符串，则按字典比较的方式对它们的16位代码单元即字符串的JavaScript字符进行比较。  
(3)否则将两个运算数转变为数字类型，然后比较它们的数值大小。  
  
#### 条件运算符  
?:  
#### void运算符  
void(expr)   expr会被执行，并返回undefined  
作用：  
void 0 等同于undefined  
避免表达式返回结果  
用作IIFE的前缀  
  
#### 对象运算符  
new delete in    
#### 一元算术运算符    
有很高的优先级  
1. 一元加法(+)  
一元加法运算符把操作数转换为数字(或者NaN) ，并返回这个转换后的数字。如果操作数本身就是数字，则直接返回这个数字。  
2. 一元减法(-)  
当“-”用做一元运算符时，它会根据需要把操作数转换为数字，然后改变运算结果的符号。  
3. 递增(++)  
递增“++”运算符对其操作数进行增量(加一)操作，操作数是一个左值(lvalue) (变量、 数组元素或对象属性)。运算符将操作数转换为数字，然后给数字加1，并将加1后的数值重新赋值给变量、数组元素或者对象属性。递增“++”运算符的返回值依赖于它相对于操作数的位置。当运算符在操作数之前，称为“前增量”运算符，它对操作数进行增量计算，并返回计算后的值。当运算符在操作数之后，称为“后增量” 运算符，它对操作数进行增量计算，但返回未做增量计算的(unincremented) 值  
vari=1,j=++i;  // i和j的值都是2  
vari=1,j=i++;  // i是2, j是1   
需要注意的是，表达式++x并不总和x=x+1完全一样，“++” 运算符从不进行字符串连接操作，它总是会将操作数转换为数字并增1。如果x是字符串“1” ，++x的结果就是数字2，而x+1是字符串“11”   
4. 递减(--)  
递减.  运算符的操作数也是一个左值。它把操作数转换为数字，然后减1,并将计算后的值重新赋值给操作数。和“++” 运算符一样，递减“--”运算符的返回值依赖于它相对操作数的位置，当递减运算符在操作数之前，操作数减1并返回减1之后的值。当递减运算符在操作数之后，操作数减1并返回减1之前的值。当递减运算符在操作符的右侧时，运算符和操作数之间不能有换行符。    
var x=1;  
x=x++;  
console.log(x);//1  
#### 位运算符  
位运算符要求它的操作数是整数   
1. 按位与(&)   
位运算符“&”对它的整型操作数逐位执行布尔与(AND) 操作。只有两个操作数中相对应的位都是1，结果中的这-位才是1。例如，0x1234 & 0x00FF = 0x0034。  
2. 按位或(|)  
位运算符“|” 对它的整型操作数逐位执行布尔或(OR)操作。如果其中一个操作数相应的位为1，或者两个操作数相应位都是1,那么结果中的这一-位就为1。 例如: 0x1234| 0x00FF = 0x12FF。  
3. 按位异或(^)  
位运算符“|”对它的整型操作数逐位执行布尔异或(XOR) 操作。异或是指第一个操作数为true或第二个操作数为true,但两者不能同时为true。如果两个操作数中只有一个相应位为1 (不能同时为1)，那么结果中的这一-位就是1。例如，0xFF00 ^ 0xF0FO = 0XOFFO。  
4. 按位非(~)  
运算符“~”是-元运算符，位于-一个整型参数之前，它将操作数的所有位取反。根据JavaScript中带符号的整数的表示方法，对-一个值使用“~”运算符相当于改变它的符号并减1。例如，~0xOF = 0xFFFFFO或-16。  
5. 左移(<<)  
将第一个操作数的所有二进制位进行左移操作，移动的位数由第二个操作数指定，移动的位数是0~31之间的一个整数。例如，在表达式a<<1中，a的第- -位变成了第二位，a的第二位变成了它的第三位，以此类推。新的第一位用0来补充，舍弃第32位。将一个值左移1位相当于它乘以2，左移两位相当于乘以4，以此类推。例如，7<<2=28。  
6. 带符号右移(>>)  
运算符“>>”将第一个操作数的所有位进行右移操作，移动的位数由第二个操作数指定，移动的位数是0~ 31之间的-一个整数。右边溢出的位将忽略。填补在左边的位由原操作数的符号决定，以便保持结果的符号与原操作数-致。如果第-一个操作数是正数，移位后用0填补最高位:如果第-一个 操作数是负的，移位后就用1填补;高位。将一个值右移1位，相当于用它除以2 (忽略余数)，右移两位，相当于它除以4，以此类推，例如，7>>1=3， -7>>1=-4.  
7. 运算符“>>>”和运算符“>>” 一样，只是左边的高位总是填补0，与原来的操作数符号无关，例如，-1>>4=-1, 但是-1>>>4=0FFFFFF。    
#### in运算符    
in运算符希望它的左操作数是-一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一一个 名为左操作数值的属性名，那么表达式返回true,例如:  
var point = { x:1, y:1 };//定义一个对象  
"x" in point// => true:对象有一个名为"x"的属性  
"z”in point// => false:对象中不存在名为" z"的属性  
 "toString" in point// => true:对象继承了toString()方法  
 #### incetanceof运算符
 #### typeof运算符  
 #### delete运算符
delete是一元操作符，它用来删除对象属性或者数组元素。就像赋值、递增、递减运.算符- -样，delete也是具有副作用的，它是用来做删除操作的，不是用来返回一个值的，例如:  
var0={x:1,y:2};//定义一个对象  
delete 0.X;//删除一个属性  
"x"in 0// => false:这个属性在对象中不再存在  
### 运算符与表达式关系  
1. 运算符是执行算术，比较和逻辑运算的特殊符号  
2. 操作符执行操作的变量和值称为操作数  
3. 运算符和操作数共同构成所谓的表达式  
4. 所有表达式都会产生一个值，这个值可以是任何数据类型，字符串、数字、布尔值等  
5. 没有任何运算符的操作数本身也被认为是表达式。（也就是字面量）  
### 表达式与语句的区别  
1. 定义区别：一个表达式会产生一个值,它可以放在任何需要一个值的地方。语句则是由分号分隔的句子或命令。如果在表达式后面加上一个“；”分隔符，这就被称为“表达式语句”。它表明“只有表达式，而没有其他语法元素的语句”。  
2. 功能区别：表达式可以放在任何需要一个值的地方。语句则是一个行为，循环语句和if语句就是典型的语句，一个程序是由一系列语句组成的。  
3. 是否支持嵌套方式的区别：在javascript中所有表达式都有返回值，表达式均可以嵌套在别的表达式中。语句不支持嵌套，语句只能独立出现。  

  
### 语句  
①语句（statement）  
 语句是为了完成某种任务而进行的操作，比如赋值语句  
 JavaScript 应用程序是由许多语法正确的语句组成的  
 JavaScript 语句是由 web 浏览器“执行”的“指令”  
②语句与表达式  
 语句主要是为了进行某种操作，一般不需要返回值  
 而表达式则是为了得到返回值，一定会返回一个值    
1. JavaScript 中的多条语句联合在一起，形成一条复合语句。用花括号将多条语句括起来——语句块  
2. 通常，语句都是以分号结束。语句块的结束不需要分号  
####  表达式语句  
赋值语句是一类比较重要的表达式语句，如：greeting="hello"+name; i*=3  
函数调用是表达式语句的另一个大类，如：alert（greeting）；  
#### 循环语句  
1. break 跳出整个循环；continue 跳出本地的循环体，立即进入下次的循环体  
①while（条件）  
   语句  
如果条件满足，就会一直循环语句，如果条件永远是真，将会产生一个无限的循环  
②do-while循环：  
  do（语句）  
    while（条件）  
首先至少会执行一次statement，接下来看条件是否是true来判断是否执行语句  
③for循环  
④for-in   可遍历一个对象中所有的键值，如果某个键值是不可枚举的，则会被忽略。遍历属性时，属性可以被删除  
不要使用for-in来遍历数组。for-in只会遍历索引，而不是数组元素；for-in还会被遍历所有的属性值。因此最好使用for循环或者数组的forEach（）方法  
⑤for each-in  只在Firefox中有效  
#### 条件语句  
1. if-then-else  
链式if语句（else if）  
2. switch  
先执行switch后的语句，再根据其结果与每条case中的label比较来判断要跳到哪个case语句，如果没有匹配的，就执行default中的语句（判断进入哪一个case是通过===来比较）  
3. with语句  
with（object）  
   语句  
 会将object的属性转变为本地变量提供给语句那部分，如：  
 var obj={first:'john'};  
 with(obj){  
   console.log('hello '+first);//hello john  
 }  
 往往用于避免过于冗余的对象调用。with语句已被遗弃  
 4. debugger语句  
 如果执行了一个debugger语句，这个语句会报一个断点；如果执行不到，不会发生任何事情  
 #### 复合语句  
1. 可以用逗号运算符 将几个表达式连接在一起，形成一个表达式，同样，JavaScript中还可以将多条语句联合在一起，形成一条复合语句。只须用花括号将多条语句括起来即可。因此，下面几行代码就可以当成一条单独的语句，使用在JavaScript中任何希望使用一条语句的地方:  
{  
x=Math.PI;  
cx=Math.cos(x);  
console.log("cos(π)="+cx);  
}  
2. 关于语句块有几点需要注意，第一，语句块的结尾不需要分号。块中的原始语句必须以分号结束，但语句块不需要。第二，语句块中的行都有缩进，这不是必需的，但整齐的缩进能让代码可读性更强，更容易理解。最后，需要注意，JavaScript中没有块级作用域，在语句块中声明的变量并不是语句块私有的  
3. 在JavaScript中，当希望多条语句被当做一条 语句使用时，使用复合语句来替代。空语句则恰好相反，它允许包含0条语句的语句，即     ；   
4. JavaScript解释器执行空语句时它显然不会执行任何动作。但实践证明，当创建一个具有空循环体的循环时，空语句有时是很有用的。例如下面的for循环  
for(i=0;i<a.length;a[i++]=0);  
5. 在这个循环中，所有的操作都在表达式a[i++]=0中完成，这里并不需要任何循环体。然而JavaScript需要循环体中至少包含一条语句，因此，这里只使用了一个单独的分号来表示一条空语句。  
#### 声明语句  
1. var和function都是声明语句，他们声明或定义变量或函数。这些语句定义标识符（变量名和函数名）并给其赋值，这些标识符可以在程序中任意地方使用  
（一）var  
1. var语句用来声明一个或多个变量。var之后跟随的是要声明的变量列表，变量中的每一个变量都可以带有初始化表达式，用于指定它的初始值。  
2. 如果var语句出现在函数体内，那么它定义的是一个局部变量，其作用域就是这个函数。如果在顶层代码中使用var语句，它声明的是全局变量，在整个JavaScript程序中都是可见的。全局变量是全局对象的属性。然而和其他全局对象属性不同的是，var声明的变量是无法通过delete删除的。  
3. 如果var语句中的变量没有指定初始化表达式，那么这个变量的值初始为undefined.变量在声明它们的脚本或函数中都是有定义的，变量声明语句会被“ 提前”至脚本或者函数的顶部。但是初始化的操作则还在原来var语句的位置执行，在声明语句之前变量的值是undefined.  
4. var语句同样可以作为for循环或者for/in循环的组成部分(和在循环之外声明的变量声明一样，这里声明的变量也会“提前” )。  
（二）function  
1. function用来定义函数  
2. funcname是要声明的函数的名称的标识符。函数名之后的圆括号中是参数列表，参数之
间使用逗号分隔。当调用函数时，这些标识符则指代传入函数的实参。  
3. 函数体是由JavaScript语句组成的，语句的数量不限，且用花括号括起来。在定义函数
时，并不执行函数体内的语句，它和调用函数时待执行的新函数对象相关联。注意,
function语句里的花括号是必需的，这和while循环和其他一些语句所使用的语句块是不
同的，即使函数体只包含一条语句，仍然必须使用花括号将其括起来。  
4. 函数声明语句通常出现在JavaScript代码的最顶层，也可以嵌套在其他函数体内。但在
嵌套时，函数声明只能出现在所嵌套函数的顶部。也就是说，函数定义不能出现在if语
句、while循环或其他任何语句中，正是由于函数声明位置的这种限制，ECMAScript标
准规范并没有将函数声明归类为真正的语句。有一些JavaScript实现的确允许在出现语句
的地方都可以进行函数声明，但是不同的实现在细节处理方式上有很大差别，因此将函
数声明放在其他的语句内的做法并不具备可移植性。  
5. 尽管函数声明语句和函数定义表达式包含相同的函数名，但二者仍然不同。两种方式都
创建了新的函数对象，但函数声明语句中的函数名是一个变量名，变量指向函数对象。  
#### 跳转  
1. 跳转语句使得JavaScript的执行可以从一个位置跳转到另一个位置。break语句是跳转到循环或者其他语句的结束。continue语句是终止本次循环的执行并开始下一次循环的执行。JavaScript中的语句可以命名或带有标签，break和continue 可以标识目标循环或者其他语句标签。  
2. return语句让解释器跳出函数体的执行，并提供本次调用的返回值。throw语句触发或者
“抛出”一个异常，它是与try/catch/finally语句一同使用的，这些语句指定了处理异常的代码逻辑。这是一种复杂的跳转语句，当抛出一个异常的时候，程序将跳转至最近的闭合异常处理程序，这个异常处理程序可以是在同一个函数中或者在更高层的调用栈中。  
（一）标签语句  
1. 语句是可以添加标签的，标签是由语句前的标识符和冒号组成：identifier：statement  
2. 通过给语句定义标签，就可以在程序的任何地方通过标签名引用这条语句。也可以对多条语句定义标签，尽管只有在给语句块定义标签时它才更有用，比如循环和条件判断语句。通过给循环定义一个标签名，可以在循环体内部使用brea k和continue来退出循环或者直接跳转到下一个循环的开始。break和continue是JavaScript中唯 一可以使用语句标签的语句  
3. 用作标签的必须是一个合法的标识符，而不能是一个保留字。标签的命名空间和变量或函数的命名空间是不同的，因此可以使用同一个标识符作为语句标签和作为变量名或函数名。语句标签只有在它所起作用的语句(当然也可以在它的子句中)内是有定义的。一个语句标签不能和它内部的语句标签重名，但在两个代码段不相互嵌套的情况下是可以出现同名的语句标签的。带有标签的语句还可以带有标签,也就是说，任何语句可以有很多个标签。  
（二）break语句  
单独使用break语句的作用是立即退出最内层的循环或switch语句或退出label指定的语句。  
不管break语句带不带标签，它的控制权都无法越过函数的边界  
（三）continue语句  
转而执行下一次循环  
不管continue语句带不带标签，他只能在循环体内使用  
（四）return语句  
return语句只能在函数体内出现。如果函数中没有return，返回undefined。即使在return后面还有很多后续代码未执行，这时也还会返回调用程序  
（五）throw语句  
throw expression；抛出异常当抛出异常时，JavaScript解释器会立即停止当前正在执行的逻辑，并跳转至就近的异常处理程序。异常处理程序是用try/catch/finally语句的catch从句编写的  
（六）try/catch/finally  
1. try/catch/finally语句是JavaScript的异常处理机制。其中try从句定义了需要处理的异
常所在的代码块。catch从句跟随在try从句之后，当try块内某处发生了异常时，调用catch内的代码逻辑。catch从句后跟随finally块， 后者中放置清理代码，不管try块中是否产生异常，finally块内的逻辑总是会执行。尽管catch和finally都是可选的，但try从句需要至少二者之一与之组成完整的语句。try. catch和finally语句块都需要使用花括号括起来，这里的花括号是必需的，即使从句中只有一条语句也不能省略花括号  
2. 通常状况下，解释器执行到try块的尾部，然后开始执行finally中的逻辑，以便进行必要
的清理工作。当由于return. continue或break语句使得解释器跳出try语句块时，解释器在执行新的目标代码之前先执行finally块中的逻辑。  
3. 如果在try中产生了异常，而且存在一条与之相关的cat ch从句来处理这个异常，解释
器会首先执行catch中的逻辑，然后执行final1y中的逻辑。如果不存在处理异常的局部
catch从句，解释器会首先执行finally中的逻辑，然后向上传播这个异常，直到找到能处
理这个异常的catch从句。  
4. 如果finally块使用了return、continue、 break或 者throw语句使程序发生跳转，或者通
过调用了抛出异常的方法改变了程序执行流程，不管这个跳转使程序挂起还是继续执行,解释器都会将其忽略。例如，如果finally从句抛出一个异常，这个异常将替代正在抛出的异常。如果finally从句运行到了return语句，尽管已经抛出了异常且这个抛出的异常还没有处理，这个方法依然会正常返回。  
5. 在没有catch从句的情况下try从句可以和finally从句一起使用。在这种情况下，finally
块只包含清理代码，不管try块中是否有break、continue或return语句, 这里的代码一定会执行，回想一下，我们无法完全精确地使用whil e循环来模拟for循环，因为continue语句在两个循环中的行为表现不一致。如果使用try/finally语句，就能使用while循环来正确模拟包含continue的for循环  
#### with语句  
with（object）  
statement  
用于扩展作用域链不推荐使用  
#### debugger语句  
debugger语句通常什么也不做。然而，当调试程序可用并运行的时候，JavaScript解释 器
将会(非必需)以调式模式运行。实际上，这条语句用来产生一个断点，JavaScript代码的执行会停止在断点的位置，这时可以使用调试器输出变量的值、检查调用栈等。例如，假设由于调用函数f()的时候使用了未定义的参数，因此f()抛出一个异常，但无法定位到底是哪里抛出了异常。为了有助于调试这个问题，需要修改函数f()  
用于断电器调试  
#### “use strict”  
1. 用途用于对脚本和函数应用严格模式  
2.   
（1）严格模式下禁止使用with语句  
（2）在严格模式中，所有的变量都要先声明，如果给一个未声明的变量、函数、函数参数、catch从句参数或全局对象的属性赋值，将会抛出一个引用错误异常(在非严格模式中，这种隐式声明的全局变量的方法是给全局对象新添加一个新属性)  
（3）在严格模式中，调用的函数(不是方法)中的一个this值是undefined。(在非严格模式中，调用的函数中的this值总是全局对象)。可以利用这种特性来判断JavaScript实现是否支持严格模式:  
var hasstrictMode = (function() { "use strict"; return this==undefined}());  
（4）同样，在严格模式中，当通过call()或apply()来调用函数时，其中的this值就是通过call()或apply()传入的第一个参数(在非严格模式中，null和undefined值被全局对象和转换为对象的非对象值所代替)。  
（5）在严格模式中，给只读属性赋值和给不可扩展的对象创建新成员都将抛出一个类型错误异常(在非严格模式中，这些操作只是简单地操作失败，不会报错)  
（6）在严格模式中，传入eval()的代码不能在调用程序所在的上下文中声明变量或定义函数，而在非严格模式中是可以这样做的。相反，变量和函数的定义是在eval()创建的新作用域中，这个作用域在eva1()返回时就弃用了。  
（7）在严格模式中，函数里的arguments对象拥有传入函数值的静态副本。在非严格模式中，arguments对象具有 “魔术般”的行为，arguments里的数组元素和函数参数都是指向同一个值的引用。  
（8）在严格模式中，当delete运算符后跟随非法的标识符(比如变量、函数、函数参数)时，将会抛出一个语法错误异常(在非严格模式中，这种delete表达式什么也没做，并返回false)。  
（9）在严格模式中，试图删除一个不可配置的属性将抛出一个类型错误异常(在非严格模式中，delete表达式操作失败，并返回false)。  
（10）在严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误(在非严格模式中不会报错)。  
（11）在严格模式中，函数声明中存在两个或多个同名的参数将产生一个语法错误(在非严格模式中不会报错)。  
（12）在严格模式中是不允许使用八进制整数直接量(以0为前缀，而不是0x为前缀)的(在非严格模式中某些实现是允许八进制整数直接量的)。   
（13）在严格模式中，标识符eva1和arguments当做关键字，它们的值是不能更改的。不能给这些标识符赋值，也不能把它们声明为变量、用做函数名、用做函数参数或用做catch块的标识符  
（14）在严格模式中限制了对调用栈的检测能力，在严格模式的函数中，arguments.caller和a rguments .callee都会抛出一个类型错误异常。严格模式的函数同样具有caller和arguments属性，当访问这两个属性时将抛出类型错误异常  




## 函数  
1. 实参>形参----额外的参数会被忽略（arguments除外），实参<形参，丢失的参数是undefined  
2. 闭包：函数以及它所连接的周围作用域中的变量即为闭包。  
3. JavaScript中函数的3种形式：  
①非方法的函数  
②构造器 通过new操作符来调用一个函数   
③方法 将一个函数存储为一个对象的属性。 
4. “形参”和“实参” 形参被用在定义函数时，实参在函数调用时被使用    
### 函数定义形式  
1. 函数是什么？函数是可以通过外部代码调用的一个“子程序”。一个函数由称为函数体的一系列语句组成。值可以传递给一个函数，函数将返回一个值。  
2. 函数定义方式  
 （1）通过函数声明的形式来定义  
      函数声明定义了一个新的变量，创建了一个函数对象，并将对象赋值给这个新的变量。  
 （2）通过函数表达式的形式来定义  
      函数表达式  
      函数表达式的值可以赋给一个变量，可以作为传入别的函数的参数等。  
      普通的函数表达式没有名字，称为匿名函数表达式。  
      具名函数表达式：具名函数表达式的名字只能在函数表达式内部被访问。 
 （3）通过 Function 构造函数实例化的形式来定义  
3. 通过 Function 构造函数创建函数  
  可以传入任意数量的实参  
  最后一个实参为函数体  
  函数体中 javascript 语句之间分号隔开  
  Function 构造函数创建一个匿名函数  
如：var max = new function("a","b","return a>b?a:b;");  
Function构造器执行传给它的JavaScript代码字符串。var add=new Function('x','y','return x+y')  
Function( )构造函数允许JavaScript在运行时动态地创建并编译函数。每次调用Function()构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。最后一点，也是关于Function()构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译总是会在顶层函数  
4. 函数定义三要素：函数名、函数的参数、函数的返回值 （但都不是必须有）  
5. ①匿名函数（如函数表达式，即没有函数名的函数）  
 单独的匿名函数是无法运行的  
 可以把匿名函数赋值给变量或立即执行  
   ②具名函数优势  
 当遇到错误时，堆栈跟踪会显示函数名，容易寻找错误  
6. 代理函数名（可有可无）  
如：var f1=function f2(){};//f2是代理函数名  
代理函数名的作用域是只能在函数的主体( FunctionBody )内部（即局部变量）  
      var f1 = function f2() {};  
      f1();  
      f2();//f2 is not defined  
var f1 = function f2() {  
   console.log(f1);  
   console.log(f2);  
   console.log(f1 === f2);//true  
}  
 f1();  
7. name属性  
返回函数实例的名称  
var f1 = function f2() {  
   console.log(f1.name);  
   console.log(f2.name);  
 };  
 f1();//f2  
        f2  
    
      var f1 = function() {};
      console.log(f1.name);//f1

      var obj = { method: function() {} };
      console.log(obj.method.name);//method

      var f1 = new Function();
      console.log(f1.name);//anonymous  
使用 new Function()语法的函数其名称为“anonymous”  
8. length 属性：length 属性指明函数定义的形参个数  
9. 函数提升   
将函数的声明放到作用域的开始  
①函数声明是完全提升的，所以在函数声明前可以进行函数调用。  
②使用var的定义也会进行代码提升，但只对于声明有效，对于赋值过程是无效的。  
10. 函数的名称  
函数的声明会创建非标准的name属性，匿名函数表达式的name是一个空字符串，具名函数表达式也有一个name。  
11. 哪个更好，函数声明还是函数表达式  
   函数声明的优势  
   ①函数声明会做代码提升，因此可以在源码中先于函数的定义来调用函数  
   ②它们具有名字，不过，JavaScript引擎也在对匿名函数表达式的名字引用做优化。  
### arguments对象  
1. JavaScript 函数在定义时有固定数目的命名参数，但当调用这个函数时，传递给它的参数数目却可以是任意的。  
2. arguments对象：代表传入函数的实参；是函数中的局部变量；不能显式创建，只有函数调用时才可用；它是一个类数组对象.arguments的length属性表传入的实参数量，在调用时，实参个数确定， arguments.length确定，不会再发生改变，只读属性。arguments并不是真正的数组  
3. 类数组对象：与数组一样具有 length 与 index 属性；本质确实个 Object  
4. arguments 与形参的“双向绑定”特性    
①实参arguments数组和形参 a b c之间的关系  
      function fun(a, b, c) {  
        console.log(a, b, c);  
        console.dir(arguments);  
        console.log(a === arguments[0]); //true  
        console.log(b === arguments[1]); //true  
        console.log(c === arguments[2]); //true  
      }  
      var obj = { x: 1, y: 2 };  
      fun(1, obj);  
②修改第一个形参a 和实参arguments[0],观察之间的关系  
      function fun(a, b, c) {  
        console.log(a === arguments[0]); //true  
        a = 2;  
        console.log(a === arguments[0]); //true  
        arguments[0] = 3;  
        console.log(a === arguments[0]); //true  
      }  
      var obj = { x: 1, y: 2 };  
      fun(1, obj);   
③修改第二个形参b 和实参arguments[1],观察之间的关系  
      function fun(a, b, c) {  
        console.log(b === arguments[1]); //true  
        b = [1, 2, 3];  
        console.log(b === arguments[1]); //true  
        arguments[1] = [2, 3, 4];  
        console.log(b === arguments[1]); //true  
      }  
      var obj = { x: 1, y: 2 };  
      fun(1, obj);   
      console.log(obj);  //[2,3,4]  
 ④修改第三个形参c 和实参arguments[2],观察之间的关系  
      function fun(a, b, c) {  
        console.log(c === arguments[2]); //true  
        c = 2;  
        console.log(arguments[2]);  
        console.log(c === arguments[2]); //false  
        arguments[2] = 3;  
        console.log(c);  
        console.log(c === arguments[2]); //false  
      }  
      var obj = { x: 1, y: 2 };  
      fun(1, obj);  
双向绑定特性：向函数传递参数时，arguments 数组中的对应单元会和命名参数建立关联（linkage）以得到相同的值。相反，不传递参数就不会建立关联  
function fun(a, b, c) {  
        console.log(arguments.length);  //2  
        arguments[4] = 1;  
        console.log(arguments.length); // arguments只与传入的实参有关系,2  
        return a + b;  
      }  
      var obj = { x: 1, y: 2 };  
      fun(1, obj);  
在调用时 arguments 对象与实际传递了值的形参变量发生双向绑定  
### call/apply/bind方法  
（ toString 方法：返回一个表示当前函数源代码的字符串。valueOf方法：返回函数本身）  
（this关键字：在function内部被创建；指向调用时所在函数所绑定的对象；this 不能被赋值，this 的值取决于函数被调用的方式） 
1. call方法  
 语法： fn.call(thisObj，arg1，arg2，...)  
 参数：arg1,arg2,...：被调用函数的实参（是一个参数序列）  
      thisObj：将函数对象中的 this 指向 thisObj 对象  
 说明：1. 如果 thisObj 未传递，this 指向全局对象 window  
      2. 如果传递为 undefined/null，this 指向全局对象 window  
      3. 如果传递为数字，字符串，布尔值，this 指向该原始值的包装对象  
 返回值：与 fn 普通调用相同  
 作用：调用函数，并改变函数执行的 this 指向  
2. apply（）方法  
语法： fn.apply(thisObj，[arg1，arg2，...])（是一个参数数组）  
其他用法均与call（）方法一样  
【call()、apply()使用仍然是执行原来对象的方法里面的代码，只是代码中的this指向改变了。如果调用的对象方法里面没有this，那么使用call()和apply()没有任何改变，也没有意义  
        var x = 100;  
        var obj = {  
            x: 50  
        };  
        var foo = {  
            x: 0,  
            getX: function () {  
                return this.x;  
            }  
        };  
        console.log(foo.getX()); //0  
        console.log(foo.getX.call(obj)); //50  
        console.log(foo.getX.apply(obj)); //50  
        //call()、apply()没有指定对象时 默认指向全局对象（window）  
        console.log(foo.getX.call()); //100  
        console.log(foo.getX.apply()); //100  】  
3.  bind () 方法  
语法： fn.bind(thisObj，arg1，arg2,...)    
参数： 当绑定函数调用时，thisObj 参数作为原函数运行时的 this 指向。  
        arg1,arg2,...  当绑定函数被调用时，这些参数加上绑定函数本身的参数会按照顺序作为 原函数运行时的参数。（预设参数）  
返回值：返回一个原函数的拷贝（绑定函数），并拥有指定的 this值和初始参数  
 bind 不会调用函数，即不会执行原函数中的代码  
4. 总结：  
 apply，call，bind 三个方法第一个参数都是改变函数在调用时 this 指向的对象  
 apply，call，bind  第一个参数为空，null，undefined，this 指向的是 window  
 apply，call 两个方法只是参数形式有所不同，apply 参数是一个数组，call 参数则是列表序列  
 apply，call 都会立即调用函数执行，bind 不会立即调用函数  
5. 参数缺失或者超出时的处理  
实参数量多于形参：多余的参数会被忽略，但是能在类数组的arguments中被获取到。  
实参数量小于形参：缺失的形参都会被赋予undefined值。  
①通过索引访问所有参数：神奇的arguments变量  
arguments变量：只存在于函数中，是一个类数组对象，包含了当前函数调用的所有实参。  
特征：它是类数组的，但又非数组。一方面，它有一个length属性，所有的参数都可以通过索引值来进行读写。 
另一方面，arguments不是一个数组，仅仅是类似，并没有数组的方法。  
它是一个对象，因此它支持所有的对象方法和操作。  
arguments的废弃特性 。arguments. callee指向了当前调用的函数。它一般用于匿名函数的自递归调用，但是它在严格模式中是禁用的。  
在非严格模式中，当改变一个参数，arguments会实时地变化，但是在严格模式中，并不支持这一特性。  
严格模式禁用了对变量arguments的分配。  
②强制性参数，限制参数数量的最小值  
判断一个参数是否缺失：第一种，检测它的值是否为undefined。第二种，将参数转化为布尔值。undefined会被认为false。第三种，用arguments.length来检测并强制指定参数数量的最小值。  
最后一种方式相比前两种有一些区别:  
前两种方式无法区分foo ()和foo (undefined)。它们对于两种情况会抛一样的错误。  
第三种方式会对foo()抛错,而对于foo (undefined)会正常使用undefined传入函数并调用。  
③可选参数  
四种处理可选参数的选择：第一种，检测undefined。第二种，将可选参数转换为布尔值。第三种，使用或运算符，如果左侧操作数不是false值，则返回左侧的操作数，否则将返回右侧的操作数。第四种，使用arguments.length来检测函数支持的最小数量的参数。  
同样的，最后一种方式有别于其他的方式:  
前三种方式无法区分bar (1,2)和bar (1, 2, undefined)。这两种情况下，opt ional的值都是默认值。  
第四种方式对于bar (1,2)会使用默认值，而对于bar (1, 2, undefined)会保留undefined的传人。  
④模拟参数的引用传递  

### prototype属性  
每一个函数都包含一个prototype属性，这个属性是指向一个对象的引用，这个对象称做“原型对象”(prototype object)。每一个函数都包含不同的原型对象。当将函数用做构造函数的时候，新创建的对象会从原型对象上继承属性。  
### toString()方法  
和所有的JavaScript对象一样，函数也有toString()方法，ECMAScript规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数(非全部)的toString()方法的实现都返回函数的完整源码。内置函数往往返回一个类似“[Inative code]”的字符串作为函数体。  

### 函数调用形式  
1. 作为函数直接调用  
2. 作为对象方法调用  
3. 作为构造函数调用  
4. 通过 call/apply 间接调用  
以上是调用的四种方法  
#### 函数调用  
1. 在一个调用中，每个参数表达式(圆括号之间的部分)都会计算出一个值，计算的结果作为参数传递给另外一个函数。这些值作为实参传递给声明函数时定义的形参。在函数体中存在一个形参的引用，指向当前传人的实参列表，通过它可以获得参数的值。  
2. 对于普通的函数调用，函数的返回值成为调用表达式的值。如果该函数返回是因为解释器到达结尾，返回值就是undefined.如果函数返回是因为解释器执行到一条return语句，返回值就是return之后的表达式的值，如果return语 句没有值，则返回undefined.  
3. 根据ECMAScript 3和非严格的ECMAScript 5对函数调用的规定，调用上下文(this的值)是全局对象。然而，在严格模式下，调用上下文则是undefined.  
4. 以函数形式调用的函数通常不使用this关键字。不过，“this” 可以用来判断当前是否是严格模式。  
#### 方法调用  
1. 对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即:调用上下文。属性访问表达式由两部分组成:一个对象和属性名称  
2. 大多数方法调用使用点符号来访问属性，使用方括号(的属性访问表达式)也可以进行属性访问操作。  
3. 方法和this关键字是面向对象编程范例的核心。任何函数只要作为方法调用实际上都会传入一个隐式的实参这个实参是一个对象，方法调用的母体就是这个对象。通常来讲，基于那个对象的方法可以执行多种操作，方法调用的语法已经很清晰地表明了函数将基于一个对象进行操作  
4. js语法不允许给this赋值  
5. 和变量不同，关键字this没有作用域的限制，嵌套的函数不会从调用它的函数中继承this。如果嵌套函数作为方法调用，其this的值指向调用它的对象。如果嵌套函数作为函数调用，其this值不是全局对象(非严格模式下)就是undefined (严格模式下)。如果你想访问这个外部函数的this值，需要将this的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。  
#### 构造函数调用  
1. var o = new Object();  
构造函数调用创建一个新的空对象， 这个对象继承自构造函数的prototype属性。构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数可以使用this关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上文。也就是说，在表达式new o.m()中，调用上下文并不是o。  
2. 构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用return语句但没有指定返回值，或者返回一个原始值,那么这时将忽略返回值，同时使用这个新对象作为调用结果。  
#### 间接调用  
JavaScript中的函数也是对象，和其他JavaScript对象没什么两样，函数对象也可以包含方法。其中的两个方法ca11()和apply()可以用来间接地调用函数。两个方法都允许显式指定调用所需的this值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。ca11()方法使用它自有的实参列表作为函数的实参, apply()方 法则要求以数组的形式传入参数。  
### 函数的形参和实参  
1. 省略的实参将是undefined，多出的参数会自动忽略  
2. JavaScript方法的形参并未声明类型，在形参传入函数体之前也未做任何类型检查。可以采用语义化的单词来给函数实参命名，或者像刚才的示例代码中的arraycopy()方法一样给实参补充注释，以此使代码自文档化，对于可选的实参来说，可以在注释中补充一下“这个实参是可选的”。当一个方法可以接收任意数量的实参时，可以使用省略号  
### 作为值的函数  
1. 函数可以定义，也可以调用，这是函数最重要的特性。函数定义和调用是JavaScript的词法特性，对于其他大多数编程语言来说亦是如此。然而在JavaScript中， 函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量,存储在对象的属性或数组的元素中，作为参数传入另外一个函数等。  
2. function square（x）{return x*/x；}  
这个定义创建一个新的函数对象，并将其赋值给变量square。函数的名字实际上是看不见的，它(square) 仅仅是变量的名字，这个变量指代函数对象。函数还可以赋值给其他的变量，并且仍可以正常工作:   
var S = square;   //现在s和square指代同一个函数  
square(4);        // => 16  
s(4);             // => 16   
3. 除了可以将函数赋值给变量，同样可以将函数赋值给对象的属性。当函数作为对象的属性调用时，函数就称为方法:  
var o = {square: function(x) { return x*/x; }}; //对象直接量   
var y = o.square(16);  //y等于256  

### 函数式编程  
#### 使用函数处理数组  
可以使用数组方法map()和reduce()来实现同样的计算，这种实现极其简洁：  
//首先定义两个简单的函数  
var sum = function(x,y) { return x+y; };  
var square = function(x) { return x*/x; };  
//然后将这些函数和数组方法配合使用计算出平均数和标准差  
var data = [1,1,3,5,5];  
var mean = data. reduce(sum)/data .1ength;  
var deviations = data . map(function(x) {return x-mean;});  
var stddev = Math.sqrt(deviations.ap(square).reduce(sum)/(data.1ength-1));  
(高阶函数)  
1. 所谓高阶函数，就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数  
（具名函数）  
调用函数或者方式时，将实参和形参做映射，有两种方式：  
通过位置来映射的位置型参数。第一个实参对应第一一个形参， 第二个实参对应 第二个形参，以此类推。  
具名参数则通过名称(标识)来做变量的映射。在一个函数的定义中名称会与 形参做关联，在函数调用中，名称则与实参做关联。只要参数的名称正确，你不需要关心参数名的顺序。  
具名参数有两个优点:它们对函数的参数进行了描述，同时它们对于处理可选参数 的场景也很有用。  
①具名参数可作为描述信息  
一个函数selectEntries()，它会从数据中返回一个入口。  
②可选的具名函数  
对于可选的位置型参数，只有当它们被放置在参数的最后时才可能正确地工作，否则，就要通过对中间的参数传入例如null的值来保持每个参数所在位置的正确性。  
③在JavaScript中模拟具名参数  
通过对象字面量来命名参数，并将对象作为一个实参传入函数。  
也可以将位置型参数和具名参数相结合。  
### 作用域、环境    
1.定义变量  
在JavaScript中，在使用变量前，你可以通过var语句来定义变量:  
var foo;  
foo = 3; // OK, has been declared  
bar = 5; // not 0K, an undeclared variable  
你也可以将赋值语句与变量定义语句合并进行变量的初始化:  
var foo = 3;  
一个未初始化的变量的值是undefined  
2. 静态性  
可以无须执行程序而只从程序源码的角度来看程序的工作。下面的代码，函数g被函数f包围在内部:
function f() {  
   function g() {  
   }  
 }  
描述性的词法就像是静态声明，因为它们都涉及了程序的词法(单词、源码)。  
3. 动态性  
它表示一个程序在运行期所表现出来的特性。  
function g() {  
}  
function f() {  
   g();  
}  
当我们调用f()，它会调用g()。在执行期间，g被f调用代表了一种动态的关系。  
4. 作用域  
(1)变量的作用域：  
变量的作用域是指变量在何处可以被访问到。例如:  
function foo() {  
var x;  
}  
这里，x的直接作用域是函数foo()。  
(2)词法作用域  
JavaScript中的变量都是有词法作用域的，因此一个程序的静态结构决定了一个变量的作用域(这个作用域并不会被函数从哪里调用等影响)。  
(3)嵌套作用域  
如果在一个变量的直接作用域中嵌套有多个作用域，那么这个变量在所有的这些作用域中都可以被访问:  
function foo(arg) {  
   function bar() {  
      console. log('arg:' +arg);  
   }  
   bar();  
}  
console. log(foo( 'hello')); // arg: hello  
arg的直接作用域是foo () ,但是它同样可以在嵌套的作用域bar ()中被访问。我们说嵌套，foo ()是外部的作用域，而bar ()是内部作用域。  
(4)覆盖  
如果在一个作用域中声明了一个与外层作用域同名的变量，那么在这个内部作用域以及其内部的所有作用域中将会访问不到外面的变量。而内部的变量的变化并不影响外部的变量，当离开内部作用域，外部变量又可以被访问了。  
var x = "global";  
   function f() {   
   var x = "local";  
   console.log(x); // local  
   }  
f();  
console.log(x); // global  
在函数f()中，全局的x被本地x所覆盖。  
5. 变量以函数为作用域  
JavaScript 的变量是函数级作用域的:只有函数可以产生新的作用域;  
代码块在作用域中是不起作用的。例如:  
function main() {  
   { // block starts  
      var foo = 4;  
   } // block ends  
   console. log(foo); // 4  
}  
换句话说，foo 在main()中都是可以被访问到的，而不仅仅是在块中。  
6. 变量声明的提前  
（一）  
①JavaScript会提前所有的变量声明，它会把所有的声明移到直接作用域的最前面。   
function f() {  
   console. log(bar); // undefined  
   var bar='abc';  
   console. log(bar); // abc  
}  
我们可以看到变量bar在函数f()的第一行已经存在了，只是还没有值;因此，被提前的是变量的声明，而非变量的复制。实际上，JavaScript 中是这样执行f()的:  
function f() {  
   var bar;  
   console. log(bar); // undefined  
   bar = ' abc';  
   console. log(bar); // abc  
}  
②如果你定义一个已经被定义过的变量，那么什么也不会发生(包括变量的值，也不会变化):  
>var x=123;  
>var x;  
>X  
123  
③函数的声明也会被提前，但是与变量截然不同，函数声明会被整体提前，而不仅仅是变量的创建的那部分  
④函数声明会被提升，但是函数表达式却不会被提升。
foo(); // 不是 ReferenceError, 而是 TypeError!  
var foo = function bar() {     // ... };  
⑤使用：  
foo(); // TypeError   
bar(); // ReferenceError  
var foo = function bar() {     // ... };  
这个代码片段经过提升后，实际上会被理解为以下形式：  
var foo;   
foo(); // TypeError  
bar(); // ReferenceError  
foo = function() {     
   var bar = ...self...     
   // ...   
}  
（二）  
函数优先  
函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个 “重复”声明的代码中）是函数会首先被提升，然后才是变量。  
考虑以下代码：  
foo(); // 1   
var foo;   
function foo() {     
   console.log( 1 );  
}   
foo = function() {  
   console.log( 2 );  
};  
会输出 1 而不是 2 ！这个代码片段会被引擎理解为如下形式：  
function foo() {    
   console.log( 1 );  
}   
foo(); // 1  
foo = function() {    
   console.log( 2 );  
};  
注意，var foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明（因此被忽 略了），因为函数声明会被提升到普通变量之前。  
尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。
foo(); // 3   
function foo() {     
   console.log( 1 );  
}   
var foo = function() {     
   console.log( 2 );  
};   
function foo() {     
   console.log( 3 );  
}  
（总结）  
JS将 var a 和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。  
声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。  
7.   
8. 全局变量  
①包含整个程序的作用域叫做全局作用域或是程序作用域。在全局作用域中，可定义函数来创建嵌套的作用域。每一个作用域都可以访问它内部以及其父作用域中的变量。由于全局作用域包含了所有的作用域，它里面的变量便可以在任何地方被访问到  
②全局作用域有两大劣势。首先，程序中依赖全局作用域的代码片段会产生一些边缘效应，程序可能不够健壮，会产生一些不可预期的效果，重用性更低。其次,一个Web页面上面的所有JavaScript都共享一个相同的全局作用域以及其全局变量:代码、内置的插件、分析代码、社交媒体按钮等。这意味着可能会产生名字的冲突的问题。这也是为什么要将变量隐藏于全局作用域之外的原因。  
9. 全局对象  
JavaScript有一些不常用的特性可以通过一个对象来为全局的变量创建环境，这个对象就叫做全局对象，全局对象可以用来创建、读取或是修改全局变量，在全局作用域中，this指向全局对象。  
注：全局对象有原型，如果要罗列它所有的属性，可以使用类似getAllPropertyNames（）的函数。  
①浏览器和Node.js全局变量引用全局对象的不同：  
浏览器中的全局对象是window,它是文档对象模型(DOM)的一部分，而非ECMAScript5的一部分。在每一个帧或者window中，都有一一个全局对象。  
Node.js中的全局对象是global,它是-一个Node.js专属的变量。每一个模块都有它自己的作用域,在这些作用域中this指向了这个作用域的对象。因此，this和global在模块中是不同的。  
②window的使用场景  
场景一：创建全局变量  
代码前面的window前缀直观的表示了代码指向了一个全局变量而非一个本地变量 var foo=123;  
这样使得程序变得脆弱，如果将foo从全局作用域移到另一个作用域中，可能会使得程序停止工作   
(function (){  
    var foo=123;  
    console.log(window.foo);  
    }());  
因此，最好将foo用一个变量来进行引用，而不是作为window的属性，加上一个例如g_的前缀。  
场景二：内置插件  
场景三：风格检查器  
JSLint,JSHint，使用window意味着,如果在当前文件中引用了一个并不定义在该文件中的全局变量,将不会得到错误提示。然而,这两个工具都会提供方式告诉它们这样的变量并避免这样的错误。  
场景四：检测一个全局变量是否存在  
if(window.someVariable){....}  
这是一种安全的检测方式,而下面的语句会在someVariable未被定义时抛出异常:  
// Don't do this  
if (someVariable) { ... }  
另外还有两种通过window来检查的方式:它们大致相同，但是更为明确:  
if (window. someVariable !== undefined) { ... }  
if ('someVariable' in window) { ... }  
检查一个变量是否存在(并是否有值)的常用方法是通过typeof   
if (typeof someVariable !== ' undefined') { ... }  
场景五：在全局作用域中创建内容  
借助window向全局作用域添加新的内容，  
if(!window.someApiFunction){
    window.someApiFunction=...;
}   
当处在全局作用域，通常将变量添加到全局作用域的最好方式是使用var，相比之下，使用window结合响应的条件判断更为清晰。  
10. 环境：变量的管理  
变量有两种传递的方式，如果有必要，有两种维度。  
(1)动态维度:调用函数  
每当一个函数被调用，它就需要给它的参数和变量准备新的存储空间。当调用结束之后，空间通常会被释放。  
function fac(n) {  
if (n<= 1) {  
return 1;  
return n * fac(n - 1);  
(2)词法维度:与外部作用域进行关联  
无论一个函数被调用了多少次，它总要访问它自己(最新)的本地变量和外部作用域的变量。例如下面的doNTimes 函数，它内部有一个辅助函数doNTimesRec,当doNTimesRec多次调用自己的时候,每一次调用都会创建一个新的环境。然而，doNTimesRec 在这多次调用中却一直与doNTimes的环境保持着联系(类似于所有的函数都共享了同一个全局环境)。在第一行中，doNTimesRec就需要通过这个联系来访问action。  
function doNTimes(n, action) {  
function doNTinesRec(x) {  
if(x>=1){  
action(); // (1)  
doNTinmesRec(x-1);  
}  
}  
doNTinesRec(n);  
}  
总结：  
(1)动态维度:执行上下文的栈
函数每调用一次，就会创建-一个新的环境将(变量和参数的)标识符和变量做映射。对于递归的情况，执行上下文，即环境的引用是在栈中进行管理的。这里的栈对应了调用栈。  
(2)词法维度:环境链  
为了支持这一维度， JavaScript 会通过内部属性[ [Scope]]来记录函数的作用域。在函数调用时，JavaScript 会为这个函数所在的新作用域创建一个环境。这个环境有一个外层域(outer) ,它通过[ [Scope]]创建并指向了外部作用域的环境。因此，在JavaScript中一直存在一个环境链，它以当前环境为起点, 连接了一层外部的环境。每一个环境链最终会在全局环境(它是所有函数初始化调用的作用域）终结。而全局环境的外部环境指向了null。  
例：  
function myFunction(myParan) {  
var myVar = 123;  
return myFloat;  
var myFloat = 1.3;  
// Step 1  
myFunction( 'abc'); // Step 2  
执行过程：  
(1)myFunction和myFloat被存在全局环境中(#0)。要注意的是myFunction所引用的函数对象通过内部属性[[Scope]]指向了它自己的作用域(全局作用域)。  
(2)而对于执行期的myFunction('abc'), JavaScript 会创建一个新的环境(#1)用来管理参数和本地变量。函数通过(从myFunction. [ [Scope] ]初始化出来的)外层链来引用外部的环境。由于外层环境链，使得myFunction可以访问到
myFloat。  

#### 块作用域  
（一）with  
with 关键字，它不仅是一个难于理解的结构，同时也是块作用域的一 个例子（块作用域的一种形式），用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。  
（二）try/catch   
 try/catch 的 catch 分句会创建一个块作 用域，其中声明的变量仅在 catch 内部有效。  
（三）let  
1. let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。换句话说，let 为其声明的变量隐式地了所在的块作用域。  
var foo = true;   
if (foo) {     
   let bar = foo * 2;     
   bar = something( bar );      
   console.log( bar );  
 }   
console.log( bar ); // ReferenceError  
2. 用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。只要声明是有效的，在声明中的任意位置都可以使用 { .. } 括号来为 let 创建一个用于绑 定的块。 
3. 使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不 “存在”。
{     
   console.log( bar ); // ReferenceError!     
   let bar = 2;  
}  
4. let循环  
for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环 的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。  
由于 let 声明附属于一个新的作用域而不是当前的函数作用域（也不属于全局作用域）， 当代码中存在对于函数作用域中 var 声明的隐式依赖时，就会有很多隐藏的陷阱，如果用 let 来替代 var 则需要在代码重构的过程中付出额外的精力。  
（四）const  
 const，同样可以用来创建块作用域变量，但其值是固定的 （常量）  
 ### 闭包  
1. 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在称为“闭包"  
2. 闭包可以捕捉到局部变量(和参数)，并一直保存下来，看起来像这些变量绑定到了在其中定义它们的外部函数。  
3. 闭包：使得函数可以维持其创建时所在的作用域  
闭包是一个函数外加上该函数创建时所建立的作用域。  
①通过环境来控制闭包  
function createInc( startValue) {  
   return function (step) {  
      startValue += step;  
      return startVa lue;  
   };  
}  
将createInc()函数，拆解为4步：  
(1)这一步在交互之前，在createInc定义之后。createInc的入口被添加到全局的环境中(#0)并指向一个函数对象。  
(2)这一步发生在函数调用createInc的执行期间。JavaScript为createInc创建了一个新的环境，并将这个环境推到栈中。它的外层环境是全局环境(即createInc. [[Scope]] )。环境中存在startValue这个变量。  
(3)这一步发生在给inc赋值时。当createInc调用结束，它所指向其环境的执行上下文就从栈中被移除了,但是其环境还存在于堆当中,因为inc. [[Scope]]还引用着。inc 是一个闭包(函数加上其创建时的环境)。  
(4)这一步在inc(1)的执行期间。一个新的环境(#1)被创建并且一个指向它的执行上下文被推入栈中。它的外层环境是inc的[[Scope]].外部环境使得inc可以访问到startValue.  
②陷阱：不经意间的环境共用  
有时候创建的函数行为可能会受当前作用域中变量的影响，通常来说每个函数应该配合函数创建时的变量值，然而，由于函数变成了闭包，函数总是会使用当前的变量值，在for循环中，这可能会使函数的工作不符合预期。  
解决方法：  
（1）为每个函数在返回的数组中创建一个新的环境。  
（2）在这个创建的新环境中存储当前i的值。  
4.   
function foo() {     
   var a = 2;   
   function bar() {        
      console.log( a );  
   }   
   return bar;   //们将 bar() 函数本身当作 一个值类型进行传递  
}  
var baz = foo();  
baz(); // 2 —— 这就是闭包的效果  
在 foo() 执行后，其返回值（也就是内部的 bar() 函数）赋值给变量 baz 并调用 baz()，实 际上只是通过不同的标识符引用调用了内部的函数 bar()。  
bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。  
在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，但是闭包会阻止这件事的发生，事实上内部作用域依然被bar()本身使用，依然存在，因此没有被回收。由于bar()声明的位置，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一 直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。  
无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包：  
function foo() {     
   var a = 2;   
   function baz() {     
      console.log( a ); // 2   
   }   
   bar( baz );  
}   
function bar(fn) {     
   fn(); // 这就是闭包！  
}  
把内部函数 baz 传递给 bar，当调用这个内部函数时（现在叫作 fn），它涵盖的 foo() 内部 作用域的闭包就可以观察到了，因为它能够访问 a。  
传递函数当然也可以是间接的：  
var fn; 
function foo() {  
   var a = 2;   
   function baz() {        
      console.log( a );   
   }   
   fn = baz; // 将 baz 分配给全局变量 
}   
function bar() {     
   fn(); // 这就是闭包！  
}   
foo();   
bar(); // 2  
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用 域的引用，无论在何处执行这个函数都会使用闭包。  
5. 通过IIFE引入新的作用域  
关于IIFE,我们有一些要注意的:   
(1)它是立即执行的  
函数的结束大括号后面的括号是用来立即调用函数的。函数体会立即执行。  
(2)它必须是一个表达式  
如果一个语句以function关键词开头，解析器会认为它是一个函数定义。但是一个函数声明并不会立即执行。因此，我们在语句前加了一个左括号告诉解析器function关键词是处于一个函数表达式的开
头。在括号中，只存在表达式。  
(3)别忘了后面的分号  
5.1  
可以通过前缀运算符来强制执行一个表达式。例如，可以用逻辑非:  
!function () { // open IIFE  
   // inside IIFE  
}(); // close IIFE  
或者是void运算符  
void function () { // open IIFE  
   // inside IIFE  
}(); // close IIFE  
使用前缀运算符的好处是忘了分号结尾并不会造成任何问题。  
5.2 预内置表达式上下文  
为IIFE强制执行表达式上下文并不是必需的，如果已经在一个表达式的上下文里面，那么不必使用括号或者前缀操作符。  
5.3 传参的IIFE  
可以使用参数的方式在IIFE的内部定义变量:  
varx=23;  
(function (twice) {  
  console. log(twice);   
}(x * 2));  
这就类似于:  
varx=23;  
(function () {  
   vartwice=x\*2;  
   console. log( twice);  
}());  
5.4 IIFE的应用  
①IIFE使得可以获取函数中的私有数据。不必定义全局变量也可以严密地将函数本身的逻辑包装在一起。这样就可以避免对全局命名空间的污染:  
var setValue = function (){  
   var prevValue;  
   return function (value) { // define setValue  
   if (value !== prevValue) {  
      console . log( 'Changed: ' + value);  
      prevValue = value ;  
   }  
   };  
}();    
②如：  
预期是分别输出数字 1~5，每秒一次，每次一个。  
for (var i=1; i<=5; i++) {     
   (function() {         
      setTimeout( function timer() {          
         console.log( i );        
      }, i\*1000 );    
   })();  
}  //这样不能满足预期效果，只会输出5次6  
改进：  
for (var i=1; i<=5; i++) {    
   (function(j) {         
      setTimeout( function timer() {           
         console.log( j );       
      }, j\*1000 );    
   })( i );  
}  
6. 模块  
（1）模式需要具备两个基本条件  
①必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块 实例）。  
②封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并 且可以访问或者修改私有的状态。  
一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用 所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。  
（3）  
function CoolModule() {    
    var something = "cool";   
    var another = [1, 2, 3];   
    function doSomething() {          
      console.log( something );    
    }   
    function doAnother() {    
      console.log( another.join( " ! " ) );   
    }   
    return {       
      doSomething: doSomething,     
      doAnother: doAnother    
    };  
 }   
var foo = CoolModule();    
foo.doSomething(); //  cool   
foo.doAnother(); // 1 ! 2 ! 3  
这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露， 这里展示的是其变体  
（4）模块也是普通的函数，因此可以接受参数。模块模式另一个简单但强大的变化用法是，命名将要作为公共 API 返回的对象  
（5）模块有两个主要特征： ①为创建内部作用域而调用了一个包装函数；②包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。  
 

























